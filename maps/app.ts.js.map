{"version":3,"sources":["C:/Users/Daniel/Dev/cloneder/controller-profile.ts","controller-profile.js","C:/Users/Daniel/Dev/cloneder/controller-share.ts","controller-share.js","data-model.js","service-user.js","util/log-submitter.js","util/social-auth.js","util/util-app.js"],"names":["app","app.ProfilePhoto","app.ProfilePhoto.constructor","app.ProfileEdit","app.ProfileEdit.constructor","app.ProfileEdit.refresh","app.ProfileEdit.saveProfile","app.ProfileEdit.selectedCount","app.ProfileEdit.deletePhotos","app.ProfileEdit.swapPhotos","app.ProfileEdit.toggleSelected","app.ProfileEdit.addPhoto","app.ProfileEdit.expandText","app.ProfileEdit.swapArrayElements","app.ShareController","app.ShareController.constructor","app.ShareController.share"],"mappings":"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","file":"app.ts.js","sourcesContent":["module app {\n\n\tclass ProfilePhoto {\n\n\t\tselected:boolean\n\t\tfile:IFile\n\n\t\tconstructor(file:IFile) {\n\t\t\tthis.file = file\n\t\t\tthis.selected = false\n\t\t}\n\t}\n\n\t/**\n\t * Controller for editing the users profile\n\t */\n\texport class ProfileEdit {\n\n\t\t// If you increase MAX_PHOTOS you will need to update LocalDB to have more profileN columns in the local SQL db\n\t\tpublic MAX_PHOTOS:number = 3\n\t\tpublic NO_IMAGE:string = 'img/add.png'\n\n\t\tpublic profile:IProfile\n\t\tpublic photos:ProfilePhoto[] = []\n\t\tpublic about:string\n\n\t\tprivate $log:ng.ILogService\n\t\tprivate $rootScope:app.IAppRootScope\n\t\tprivate $scope:ng.IScope\n\t\tprivate $state\n\t\tprivate $q:ng.IQService\n\t\tprivate $ionicActionSheet\n\t\tprivate $cordovaCamera\n\t\tprivate AppService:IAppService\n\t\tprivate AppUtil\n\n\t\tconstructor($log:ng.ILogService, $rootScope:app.IAppRootScope, $scope:ng.IScope, $q:ng.IQService,\n\t\t\t\t\t$state, $ionicActionSheet, $cordovaCamera, AppService:IAppService, AppUtil) {\n\t\t\tthis.$log = $log\n\t\t\tthis.$rootScope = $rootScope\n\t\t\tthis.$scope = $scope\n\t\t\tthis.$q = $q\n\t\t\tthis.$state = $state\n\t\t\tthis.$ionicActionSheet = $ionicActionSheet\n\t\t\tthis.$cordovaCamera = $cordovaCamera\n\t\t\tthis.AppService = AppService\n\t\t\tthis.AppUtil = AppUtil\n\t\t\t// this.$translate = $translate\n\n\t\t\tthis.$scope.$on('$ionicView.beforeEnter', () => this.refresh())\n\t\t\tthis.$scope.$on('$ionicView.enter', () => this.expandText())\n\t\t}\n\n\n\t\tprivate refresh() {\n\t\t\tthis.profile = this.AppService.getProfile()\n\t\t\tthis.about = this.profile.about\n\t\t\tthis.photos = _.map(this.profile.photos, photo => new ProfilePhoto(photo))\n\t\t}\n\n\n\t\tpublic saveProfile() {\n\t\t\tlet profileUpdate = <IProfile>{}\n\t\t\tprofileUpdate.about = this.about\n\t\t\tthis.AppUtil.blockingCall(\n\t\t\t\tthis.AppService.saveProfile(profileUpdate),\n\t\t\t\t() => this.refresh()\n\t\t\t)\n\t\t}\n\n\t\tpublic selectedCount() {\n\t\t\treturn _.filter(this.photos, (photo) => photo.selected).length\n\t\t}\n\n\t\t/**\n\t\t * Deletes the selected photos from the profile\n\t\t */\n\t\tpublic deletePhotos() {\n\t\t\t// Extract the unselected photos and update the profile with those\n\t\t\tlet remainingPhotos = _.filter(this.photos, (photo) => !photo.selected)\n\n\t\t\tlet profileUpdate = <IProfile>{}\n\t\t\tprofileUpdate.photos = _.map(remainingPhotos, (photo) => photo.file)\n\n\t\t\tthis.AppUtil.blockingCall(\n\t\t\t\tthis.AppService.saveProfile(profileUpdate),\n\t\t\t\t() => this.refresh()\n\t\t\t)\n\t\t}\n\n\t\t/**\n\t\t * Swaps the position of the selected photos. This should only be called when there is two selected.\n\t\t */\n\t\tpublic swapPhotos() {\n\t\t\t// Find the indexes of the two selected photos\n\t\t\tlet first = _.findIndex(this.photos, photo => photo.selected)\n\t\t\tlet last = _.findLastIndex(this.photos, photo => photo.selected)\n\n\t\t\tlet profileUpdate = <IProfile>{}\n\t\t\tthis.swapArrayElements(this.photos, first, last)\n\t\t\tprofileUpdate.photos = _.map(this.photos, (photo) => photo.file)\n\n\t\t\tthis.AppUtil.blockingCall(\n\t\t\t\tthis.AppService.saveProfile(profileUpdate),\n\t\t\t\t() => this.refresh()\n\t\t\t)\n\t\t}\n\n\t\t/**\n\t\t * Toggle the selected state of a photo\n\t\t * @param index the photos array index\n\t\t */\n\t\tpublic toggleSelected(photo) {\n\t\t\tphoto.selected = !photo.selected\n\t\t}\n\n\t\t/**\n\t\t * Add a profile photo\n\t\t */\n\t\tpublic addPhoto() {\n\t\t\tvar buttons = [{text: 'Take Photo'}, {text: 'Gallery'}]\n\t\t\tif (this.$rootScope.facebookConnected)\n\t\t\t\tbuttons.push({text: 'Facebook'})\n\n\t\t\tthis.$ionicActionSheet.show({\n\t\t\t\tbuttons: buttons,\n\t\t\t\ttitleText: 'Select photo source',\n\t\t\t\tcancelText: 'Cancel',\n\t\t\t\tbuttonClicked: index => {\n\t\t\t\t\tif (index === 2) {\n\t\t\t\t\t\tthis.$state.go('^.fb-albums')\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!ionic.Platform.isWebView()) {\n\t\t\t\t\t\t\t// this.$ionicPopup.alert({ title: 'Only works on a real phone!' }) // .then(function(){})\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet sourceType:number = index === 0 ? Camera.PictureSourceType.CAMERA :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tCamera.PictureSourceType.PHOTOLIBRARY\n\n\t\t\t\t\t\tvar options = {\n\t\t\t\t\t\t\tquality: 70,\n\t\t\t\t\t\t\tdestinationType: Camera.DestinationType.DATA_URL,\n\t\t\t\t\t\t\tsourceType: sourceType,\n\t\t\t\t\t\t\tallowEdit: false, // allowEdit allows native cropping. However not all devices support it, so just use JavaScript cropping for now\n\t\t\t\t\t\t\tencodingType: Camera.EncodingType.PNG,\n\t\t\t\t\t\t\ttargetWidth: 800,\n\t\t\t\t\t\t\ttargetHeight: 800,\n\t\t\t\t\t\t\tpopoverOptions: CameraPopoverOptions,\n\t\t\t\t\t\t\tsaveToPhotoAlbum: false\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.$cordovaCamera.getPicture(options).then(imageData => {\n\t\t\t\t\t\t\t// TODO don't use root scope - pass as param\n\t\t\t\t\t\t\tvar dataUrl = 'data:image/jpeg;base64,' + imageData\n\t\t\t\t\t\t\tthis.$rootScope.cropPhoto = dataUrl\n\t\t\t\t\t\t\tthis.$state.go('^.crop') // , {imageData: 'data:image/jpeg;base64,' + imageData}\n\t\t\t\t\t\t}, function(error) {\n\t\t\t\t\t\t\tthis.AppUtil.toastSimple('Error getting photo')\n\t\t\t\t\t\t\tthis.$log.error('$cordovaCamera.getPicture error ' + JSON.stringify(error))\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\n\t\tprivate expandText() {\n\t\t\t// var element = document.getElementById('aboutYou')\n\t\t\tvar element = <HTMLTextAreaElement>document.querySelector('#aboutYou')\n\t\t\telement.style.height = element.scrollHeight + 'px'\n\t\t}\n\n\t\t/**\n\t\t * Swap the elements in an array at indexes x and y.\n\t\t *\n\t\t * @param (array) The array.\n\t\t * @param (a) The index of the first element to swap.\n\t\t * @param (b) The index of the second element to swap.\n\t\t */\n\t\tprivate swapArrayElements(array:any[], a, b) {\n\t\t\tvar temp = array[a]\n\t\t\tarray[a] = array[b]\n\t\t\tarray[b] = temp\n\t\t}\n\n\t}\n\n\tProfileEdit.$inject = ['$log', '$rootScope', '$scope', '$q', '$state', '$ionicActionSheet', '$cordovaCamera', 'AppService', 'AppUtil']\n\tangular.module('controllers').controller('ProfileEdit', ProfileEdit)\n}\n","var app;\n(function (app) {\n    var ProfilePhoto = (function () {\n        function ProfilePhoto(file) {\n            this.file = file;\n            this.selected = false;\n        }\n        return ProfilePhoto;\n    })();\n    /**\n     * Controller for editing the users profile\n     */\n    var ProfileEdit = (function () {\n        function ProfileEdit($log, $rootScope, $scope, $q, $state, $ionicActionSheet, $cordovaCamera, AppService, AppUtil) {\n            var _this = this;\n            // If you increase MAX_PHOTOS you will need to update LocalDB to have more profileN columns in the local SQL db\n            this.MAX_PHOTOS = 3;\n            this.NO_IMAGE = 'img/add.png';\n            this.photos = [];\n            this.$log = $log;\n            this.$rootScope = $rootScope;\n            this.$scope = $scope;\n            this.$q = $q;\n            this.$state = $state;\n            this.$ionicActionSheet = $ionicActionSheet;\n            this.$cordovaCamera = $cordovaCamera;\n            this.AppService = AppService;\n            this.AppUtil = AppUtil;\n            // this.$translate = $translate\n            this.$scope.$on('$ionicView.beforeEnter', function () { return _this.refresh(); });\n            this.$scope.$on('$ionicView.enter', function () { return _this.expandText(); });\n        }\n        ProfileEdit.prototype.refresh = function () {\n            this.profile = this.AppService.getProfile();\n            this.about = this.profile.about;\n            this.photos = _.map(this.profile.photos, function (photo) { return new ProfilePhoto(photo); });\n        };\n        ProfileEdit.prototype.saveProfile = function () {\n            var _this = this;\n            let profileUpdate = {};\n            profileUpdate.about = this.about;\n            this.AppUtil.blockingCall(this.AppService.saveProfile(profileUpdate), function () { return _this.refresh(); });\n        };\n        ProfileEdit.prototype.selectedCount = function () {\n            return _.filter(this.photos, function (photo) { return photo.selected; }).length;\n        };\n        /**\n         * Deletes the selected photos from the profile\n         */\n        ProfileEdit.prototype.deletePhotos = function () {\n            var _this = this;\n            // Extract the unselected photos and update the profile with those\n            let remainingPhotos = _.filter(this.photos, function (photo) { return !photo.selected; });\n            let profileUpdate = {};\n            profileUpdate.photos = _.map(remainingPhotos, function (photo) { return photo.file; });\n            this.AppUtil.blockingCall(this.AppService.saveProfile(profileUpdate), function () { return _this.refresh(); });\n        };\n        /**\n         * Swaps the position of the selected photos. This should only be called when there is two selected.\n         */\n        ProfileEdit.prototype.swapPhotos = function () {\n            var _this = this;\n            // Find the indexes of the two selected photos\n            let first = _.findIndex(this.photos, function (photo) { return photo.selected; });\n            let last = _.findLastIndex(this.photos, function (photo) { return photo.selected; });\n            let profileUpdate = {};\n            this.swapArrayElements(this.photos, first, last);\n            profileUpdate.photos = _.map(this.photos, function (photo) { return photo.file; });\n            this.AppUtil.blockingCall(this.AppService.saveProfile(profileUpdate), function () { return _this.refresh(); });\n        };\n        /**\n         * Toggle the selected state of a photo\n         * @param index the photos array index\n         */\n        ProfileEdit.prototype.toggleSelected = function (photo) {\n            photo.selected = !photo.selected;\n        };\n        /**\n         * Add a profile photo\n         */\n        ProfileEdit.prototype.addPhoto = function () {\n            var _this = this;\n            var buttons = [{ text: 'Take Photo' }, { text: 'Gallery' }];\n            if (this.$rootScope.facebookConnected)\n                buttons.push({ text: 'Facebook' });\n            this.$ionicActionSheet.show({\n                buttons: buttons,\n                titleText: 'Select photo source',\n                cancelText: 'Cancel',\n                buttonClicked: function (index) {\n                    if (index === 2) {\n                        _this.$state.go('^.fb-albums');\n                    }\n                    else {\n                        if (!ionic.Platform.isWebView()) {\n                            // this.$ionicPopup.alert({ title: 'Only works on a real phone!' }) // .then(function(){})\n                            return true;\n                        }\n                        let sourceType = index === 0 ? Camera.PictureSourceType.CAMERA : Camera.PictureSourceType.PHOTOLIBRARY;\n                        var options = {\n                            quality: 70,\n                            destinationType: Camera.DestinationType.DATA_URL,\n                            sourceType: sourceType,\n                            allowEdit: false,\n                            encodingType: Camera.EncodingType.PNG,\n                            targetWidth: 800,\n                            targetHeight: 800,\n                            popoverOptions: CameraPopoverOptions,\n                            saveToPhotoAlbum: false\n                        };\n                        _this.$cordovaCamera.getPicture(options).then(function (imageData) {\n                            // TODO don't use root scope - pass as param\n                            var dataUrl = 'data:image/jpeg;base64,' + imageData;\n                            _this.$rootScope.cropPhoto = dataUrl;\n                            _this.$state.go('^.crop'); // , {imageData: 'data:image/jpeg;base64,' + imageData}\n                        }, function (error) {\n                            this.AppUtil.toastSimple('Error getting photo');\n                            this.$log.error('$cordovaCamera.getPicture error ' + JSON.stringify(error));\n                        });\n                    }\n                    return true;\n                }\n            });\n        };\n        ProfileEdit.prototype.expandText = function () {\n            // var element = document.getElementById('aboutYou')\n            var element = document.querySelector('#aboutYou');\n            element.style.height = element.scrollHeight + 'px';\n        };\n        /**\n         * Swap the elements in an array at indexes x and y.\n         *\n         * @param (array) The array.\n         * @param (a) The index of the first element to swap.\n         * @param (b) The index of the second element to swap.\n         */\n        ProfileEdit.prototype.swapArrayElements = function (array, a, b) {\n            var temp = array[a];\n            array[a] = array[b];\n            array[b] = temp;\n        };\n        return ProfileEdit;\n    })();\n    app.ProfileEdit = ProfileEdit;\n    ProfileEdit.$inject = ['$log', '$rootScope', '$scope', '$q', '$state', '$ionicActionSheet', '$cordovaCamera', 'AppService', 'AppUtil'];\n    angular.module('controllers').controller('ProfileEdit', ProfileEdit);\n})(app || (app = {}));\n","module app {\n\n\t/**\n\t * Controller for the social sharing action\n\t */\n\texport class ShareController {\n\n\t\tprivate $log:ng.ILogService\n\t\tprivate $cordovaSocialSharing\n\t\tprivate socialShareMessage:string\n\n\t\tconstructor($log:ng.ILogService, $cordovaSocialSharing, socialShareMessage:string) {\n\t\t\tthis.$log = $log\n\t\t\tthis.$cordovaSocialSharing = $cordovaSocialSharing\n\t\t\tthis.socialShareMessage = socialShareMessage\n\t\t}\n\n\n\t\tpublic share() {\n\t\t\tthis.$cordovaSocialSharing\n\t\t\t\t.share(this.socialShareMessage) // Share via native share sheet\n\t\t\t\t.then(() => {\n\t\t\t\t\tthis.$log.debug('Social share action complete')\n\t\t\t\t}, error => {\n\t\t\t\t\tthis.$log.error('Social share action error ' + JSON.stringify(error))\n\t\t\t\t})\n\t\t}\n\t}\n\n\tShareController.$inject = ['$log', '$cordovaSocialSharing', 'socialShareMessage']\n\tangular.module('controllers.share', ['constants', 'ngCordova.plugins.socialSharing']).controller('ShareController', ShareController)\n}\n","var app;\n(function (app) {\n    /**\n     * Controller for the social sharing action\n     */\n    var ShareController = (function () {\n        function ShareController($log, $cordovaSocialSharing, socialShareMessage) {\n            this.$log = $log;\n            this.$cordovaSocialSharing = $cordovaSocialSharing;\n            this.socialShareMessage = socialShareMessage;\n        }\n        ShareController.prototype.share = function () {\n            var _this = this;\n            this.$cordovaSocialSharing.share(this.socialShareMessage).then(function () {\n                _this.$log.debug('Social share action complete');\n            }, function (error) {\n                _this.$log.error('Social share action error ' + JSON.stringify(error));\n            });\n        };\n        return ShareController;\n    })();\n    app.ShareController = ShareController;\n    ShareController.$inject = ['$log', '$cordovaSocialSharing', 'socialShareMessage'];\n    angular.module('controllers.share', ['constants', 'ngCordova.plugins.socialSharing']).controller('ShareController', ShareController);\n})(app || (app = {}));\n",null,"\r\n// Callback for push notifications, which passes it into the Angular code\r\nfunction onNotification(pnObj){\r\n\tconsole.log(\"Received push notification: \" + JSON.stringify(pnObj))\r\n\tvar appService = angular.element(document.body).injector().get('AppService')\r\n\r\n\tappService.pushNotificationReceived()\r\n\r\n\tif(pnObj.type == 'message')\r\n\t\tappService.newMessageNotification(pnObj.message)\r\n\telse if(pnObj.type == 'match')\r\n\t\tappService.newMatchNotification(pnObj.matchId)\r\n\telse if(pnObj.type == 'removeMatch')\r\n\t\tappService.removeMatchNotification(pnObj.matchId)\r\n\r\n}\r\n\r\nfunction onNotificationOpen(pnObj){\r\n\tconsole.log(\"Opened push notification: \" + JSON.stringify(pnObj))\r\n\tvar appService = angular.element(document.body).injector().get('AppService')\r\n\tvar state = angular.element(document.body).injector().get('$state')\r\n\r\n\tif(pnObj.type == 'message') {\r\n\t\tconsole.log('going to menu.chat ' + pnObj.message.match.id)\r\n\t\tstate.go('menu.chat', {matchId: pnObj.message.match.id})\r\n\t}\r\n\telse if(pnObj.type == 'match') {\r\n\t\tconsole.log('going to menu.match-profile ' + pnObj.matchId)\r\n\t\tstate.go('menu.match-profile', {matchId: pnObj.matchId})\r\n\t}\r\n}\r\n\r\n\r\n(function() {\r\n\r\n\tangular.module('service.app', ['ngCordova', 'service.parse', 'service.localdb'])\r\n    .factory('AppService', function($rootScope, $timeout, $http, $cordovaFacebook, $cordovaGeolocation, $cordovaMedia,\r\n\t\t\t\t\t\t\t\t\t$log, $state, $q, $ionicHistory, ParseService, LocalDB, $localStorage, $interval,\r\n\t\t\t\t\t\t\t\t\t$analytics) {\r\n\r\n\t\tvar server = ParseService\r\n\r\n\t\t// keep a reference to the mutual matches so we can update when a push notification arrives for a new match\r\n\t\tvar matches = []\r\n\r\n\t\t// Contains the match/chat ids which have unread chat messages as properties\r\n\t\tvar unreadChats = {}\r\n\t\t// The total number of matches/chats that have unread messages. This must be updated when unreadChats is updated\r\n\t\tvar unreadChatsCount = 0\r\n\r\n\t\tvar profileCache = []\r\n\r\n\t\t// keep a reference to the current chat messages so we can update when a push notification arrives\r\n\t\tvar activeChatMatchId = null\r\n\t\tvar activeChatMessages = null\r\n\r\n\t\t// Variables for the polling when push notifications haven't been detected\r\n\t\tconst CHAT_SYNC_INTERVAL = 60000\r\n\t\tconst MATCH_SYNC_RATIO = 10 // After how many chat syncs we should also sync the matches\r\n\t\tvar syncCount = 0\r\n\t\tvar synchronizeInterval = null\r\n\r\n\t\tvar service = {\r\n\t\t\t// fields\r\n\t\t\tisLoggedIn : false,\r\n\t\t\tuserId : '',\r\n\t\t\tfbId : '',\r\n\t\t\tprofile : null,\r\n\t\t\tpotentialMatches : null,\r\n\t\t\t// methods\r\n\t\t\tinit : init,\r\n\t\t\tfacebookLogin: facebookLogin,\r\n\t\t\tlinkedInLogin: linkedInLogin,\r\n\t\t\tsignUp : signUp,\r\n\t\t\tlogIn : logIn,\r\n            autoLogin : autoLogin,\r\n\t\t\treloadUser : reloadUser,\r\n            isEmailVerified : isEmailVerified,\r\n\t\t\ttermsOfUseAgreed: termsOfUseAgreed,\r\n            requestPasswordReset : requestPasswordReset,\r\n\t\t\tgoToNextLoginState : goToNextLoginState,\r\n\t\t\tloadProfile : loadProfile,\r\n\t\t\tgetProfile : getProfile,\r\n\t\t\tgetProfileById : getProfileById,\r\n\t\t\tgetProfileByMatchId : getProfileByMatchId,\r\n\t\t\tsaveBirthdate : saveBirthdate,\r\n\t\t\tsaveProfile : saveProfile,\r\n\t\t\tsaveSettings : saveSettings,\r\n\t\t\tenableDiscovery : enableDiscovery,\r\n\t\t\tgetCurrentPosition : getCurrentPosition,\r\n\t\t\tcopyFacebookProfile : copyFacebookProfile,\r\n\t\t\tsetPhoto : setPhoto,\r\n\t\t\tgetPotentialMatches: getPotentialMatches,\r\n\t\t\tupdatePotentialMatches: updatePotentialMatches,\r\n\t\t\tclearPotentialMatches: clearPotentialMatches,\r\n\t\t\tnewMatchNotification : newMatchNotification,\r\n\t\t\tremoveMatchNotification : removeMatchNotification,\r\n            deleteUnmatched : deleteUnmatched,\r\n\t\t\tprocessMatch : processMatch,\r\n\t\t\tgetMutualMatches : getMutualMatches,\r\n\t\t\tgetMatch : getMatch,\r\n\t\t\tgetActiveChat : getActiveChat,\r\n\t\t\tsetChatRead: setChatRead,\r\n\t\t\tgetUnreadChatsCount: getUnreadChatsCount,\r\n\t\t\tsendChatMessage : sendChatMessage,\r\n\t\t\tremoveMatch : removeMatch,\r\n\t\t\treportProfile : reportProfile,\r\n\t\t\tnewMessageNotification : newMessageNotification,\r\n\t\t\tpushNotificationReceived : pushNotificationReceived,\r\n\t\t\tresetBadge: resetBadge,\r\n\t\t\tsendContactMessage: sendContactMessage,\r\n\t\t\tlogout : logout,\r\n\t\t\tdeleteAccount: deleteAccount\r\n\t\t}\r\n\r\n\t\treturn service\r\n\r\n\r\n\t\tfunction init() {\r\n\t\t\tLocalDB.init()\r\n\t\t\t\t.then(() => LocalDB.getMatches())\r\n\t\t\t\t.then(dbMatches => {\r\n\t\t\t\t\tfor(let match of dbMatches) {\r\n\t\t\t\t\t\tmatches.push(match)\r\n\t\t\t\t\t\tprofileCache[match.profile.id] = match.profile\r\n\t\t\t\t\t}\r\n\t\t\t\t}, error => $log.error('Error loading db matches ' + JSON.stringify(error)))\r\n\r\n\t\t\tserver.init()\r\n\t\t}\r\n\r\n\t\tfunction facebookLogin(facebookResponse) {\r\n\t\t\t$analytics.eventTrack('facebookLogin')\r\n\t\t\treturn server.facebookLogin(facebookResponse).then(function(result){\r\n\t\t\t\tservice.userId = server.getUserId()\r\n\t\t\t\treturn result;\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tfunction linkedInLogin(authData) {\r\n\t\t\t$analytics.eventTrack('linkedInLogin')\r\n\t\t\treturn server.linkedInLogin(authData).then(user => {\r\n\t\t\t\tservice.userId = user.id\r\n\t\t\t\treturn $q.when(user)\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tfunction signUp(email, password) {\r\n\t\t\t$analytics.eventTrack('signupEmail')\r\n\t\t\treturn server.signUp(email, password).then(function(result){\r\n\t\t\t\tservice.userId = server.getUserId()\r\n\t\t\t\treturn result;\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tfunction logIn(email, password) {\r\n\t\t\t$analytics.eventTrack('loginEmail')\r\n\t\t\treturn server.logIn(email, password).then(function(result){\r\n\t\t\t\tservice.userId = server.getUserId()\r\n\t\t\t\treturn result;\r\n\t\t\t})\r\n\t\t}\r\n\r\n        function autoLogin() {\r\n            server.autoLogin()\r\n        }\r\n\r\n\r\n\t\tfunction reloadUser() {\r\n\t\t\treturn server.reloadUser()\r\n\t\t}\r\n\r\n        function isEmailVerified() {\r\n            return server.reloadUser().then(function(user) {\r\n\t\t\t\treturn user.emailVerified === true\r\n\t\t\t})\r\n        }\r\n\r\n\r\n\t\t/**\r\n\t\t * Set that the user has agreed to the terms of use\r\n\t\t * @returns {IPromise<void>}\r\n\t\t */\r\n\t\tfunction termsOfUseAgreed() {\r\n\t\t\t$localStorage.termsOfUseAgreed = true\r\n\t\t\treturn $q.when()\r\n\t\t}\r\n\r\n        function requestPasswordReset(email) {\r\n            $analytics.eventTrack('passwordReset')\r\n            return server.requestPasswordReset(email)\r\n        }\r\n\r\n\t\t/**\r\n\t\t * Loads the profile for the current user. Returns a promise as it will need call the serve the first time.\r\n\t\t * @returns {Promise<IProfile>}\r\n\t\t */\r\n\t\tfunction loadProfile() {\r\n\t\t\tif (service.profile)\r\n\t\t\t\treturn $q.when(service.profile)\r\n\r\n\t\t\treturn server.getProfile()\r\n\t\t\t\t.then(function(result) {\r\n\t\t\t\t\tif(!result)\r\n\t\t\t\t\t\treturn null\r\n\r\n\t\t\t\t\tif(_.isUndefined(result.gps)) result.gps = true // migration for the new field. Can be deleted sometime\r\n\t\t\t\t\t$log.log('AppService server.getProfile returned ' + result)\r\n\t\t\t\t\tservice.profile = result\r\n\t\t\t\t\treturn service.profile\r\n\t\t\t\t})\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Get the profile for the current user. loadProfile() must be called before this is called.\r\n\t\t * @returns {IProfile}\r\n\t\t */\r\n\t\tfunction getProfile() {\r\n\t\t\treturn service.profile\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Get the profile for a mutual match\r\n\t\t * @param matchId the mutual match id\r\n\t\t * @returns {Promise<IProfile>}\r\n\t\t */\r\n\t\tfunction getProfileByMatchId(matchId) {\r\n\t\t\t$log.debug('getProfileByMatchId ' + matchId)\r\n\r\n\t\t\tlet match = matches[matchId]\r\n\t\t\tif(match) {\r\n\t\t\t\tlet profile = profileCache[match.profileId]\r\n\t\t\t\tif(profile)\r\n\t\t\t\t\treturn $q.when(profile)\r\n\t\t\t}\r\n\r\n\t\t\treturn server.getProfileForMatch(matchId).then(profile => {\r\n\t\t\t\tprofileCache[profile.id] = profile\r\n\t\t\t\treturn profile\r\n\t\t\t})\r\n\t\t}\r\n\r\n\r\n\t\tfunction getProfileById(profileId) {\r\n\t\t\treturn profileCache[profileId]\r\n\t\t}\r\n\r\n\r\n\t\tfunction goToNextLoginState() {\r\n\r\n\t\t\tvar user = Parse.User.current()\r\n\t\t\t// If users have authenticated with Facebook then don't require email verification\r\n\t\t\t// Note: there are three states to emailVerified in Parse. undefined means it is not required, eg user signed up before email verification was enabled\r\n\t\t\tif(!$rootScope.facebookConnected && user.emailVerified === false) {\r\n\t\t\t\tgo('emailVerification')\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tif(!isProfileValid()) {\r\n\t\t\t\tgo('profileSetup')\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tif(!getProfile().location) {\r\n\t\t\t\tgo('locationSetup')\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tif(!$localStorage.termsOfUseAgreed) {\r\n\t\t\t\tgo('termsOfUse')\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\t// TODO welcome/intro slides\r\n\r\n\t\t\tstartSynchronisation()\r\n\r\n\t\t\tgo('menu.home')\r\n\t\t}\r\n\r\n\t\tfunction go(state) {\r\n\t\t\t$ionicHistory.nextViewOptions({\r\n\t\t\t\thistoryRoot: true,\r\n\t\t\t\tdisableBack: true\r\n\t\t\t})\r\n\t\t\t$state.go(state)\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Syncs to the server and starts the polling synchronization if required\r\n\t\t */\r\n\t\tfunction startSynchronisation() {\r\n\r\n\t\t\tvar syncFunction = () => {\r\n\t\t\t\tif(++syncCount === MATCH_SYNC_RATIO) {\r\n\t\t\t\t\tsyncCount = 0\r\n\t\t\t\t\tsynchronizeMutualMatches().always(synchronizeChatMessages)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsynchronizeChatMessages()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Sync on startup\r\n\t\t\tsynchronizeMutualMatches().always(synchronizeChatMessages)\r\n\r\n\t\t\t// Check if we need to start polling for updates\r\n\t\t\t// If we have received a push notification, then we'll rely on them to\r\n\t\t\t// update while the app is running\r\n\t\t\tif(!synchronizeInterval && !$localStorage.pushNotificationReceived) {\r\n\t\t\t\t$log.log('Starting polling synchronization')\r\n\t\t\t\t// Start an interval timer to sync periodically\r\n\t\t\t\tsynchronizeInterval = $interval(syncFunction, CHAT_SYNC_INTERVAL)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * @returns {boolean} if the profile contains the all minimum data required to use the main application\r\n\t\t */\r\n\t\tfunction isProfileValid() {\r\n\t\t\treturn service.profile.birthdate && service.profile.name && service.profile.gender\r\n\t\t}\r\n\r\n\r\n\t\tfunction getCurrentPosition() {\r\n\t\t\t// see http://stackoverflow.com/questions/3397585/navigator-geolocation-getcurrentposition-sometimes-works-sometimes-doesnt\r\n\t\t\t$log.log('getCurrentPosition()')\r\n\r\n\t\t\tvar timeout = 10000\r\n\t\t\tvar q = $q.defer()\r\n\r\n\t\t\tvar geolocFail = function() {\r\n\t\t\t\t$log.log('$cordovaGeolocation.getCurrentPosition did not return within the timeout')\r\n\t\t\t\tq.reject('GEO_ERROR')\r\n\t\t\t}\r\n\t\t\tvar timer = $timeout(geolocFail, timeout + 1000); // wait an extra second longer than the expected geo timeout\r\n\r\n\t\t\t$cordovaGeolocation.getCurrentPosition().then(function(location){\r\n\t\t\t\t$timeout.cancel(timer);\r\n\t\t\t\t$log.log('location ' + JSON.stringify(location))\r\n\t\t\t\tvar geoPoint = server.convertLocation(location.coords.latitude, location.coords.longitude)\r\n\t\t\t\tq.resolve(geoPoint)\r\n\t\t\t}, function(error){\r\n\t\t\t\t$timeout.cancel(timer);\r\n\t\t\t\t$log.log('getCurrentPosition error: ' + JSON.stringify(error))\r\n\r\n\t\t\t\t//if(error.code == 1){\r\n\t\t\t\t//\talert('You have denied app access to location');\r\n\t\t\t\t//} else {\r\n\t\t\t\t//\talert('code: '    + error.code    + '\\n' +\r\n\t\t\t\t//\t'message: ' + error.message + '\\n');\r\n\t\t\t\t//}\r\n\r\n\t\t\t\tq.reject('GEO_ERROR')\r\n\t\t\t}, { maximumAge: 3600000, timeout: timeout, enableHighAccuracy: true })\r\n\r\n\t\t\treturn q.promise\r\n\r\n\t\t\t// simple way without wrapping in a timer\r\n\t\t\t//return $cordovaGeolocation.getCurrentPosition().then(function(location){\r\n\t\t\t//\t$log.log(JSON.stringify(location))\r\n\t\t\t//\treturn server.convertLocation(location.coords.latitude, location.coords.longitude)\r\n\t\t\t//}, function(error){\r\n\t\t\t//\t$log.log('position error: ' + JSON.stringify(error))\r\n\t\t\t//\treturn $q.reject(error)\r\n\t\t\t//}, { maximumAge: 1000000, timeout: 2000, enableHighAccuracy: true })\r\n\t\t}\r\n\r\n\t\tfunction saveSettings(profile) {\r\n\t\t\tvar mods = {notifyMatch: profile.notifyMatch, notifyMessage:profile.notifyMessage, distanceType:profile.distanceType}\r\n\t\t\treturn server.saveSettings(service.profile, mods)\r\n\t\t\t\t.then(function(result) {\r\n\t\t\t\t\t$log.log('saveSettings result:' + JSON.stringify(result))\r\n\t\t\t\t\treturn service.profile\r\n\t\t\t\t})\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Update the user profile with their Facebook profile data\r\n\t\t * @returns {ng.IPromise<IProfile>} the user profile\r\n\t\t */\r\n\t\tfunction copyFacebookProfile() {\r\n\t\t\treturn server.copyFacebookProfile().then(profile => {\r\n\t\t\t\tservice.profile = profile\r\n\t\t\t\treturn service.profile\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tfunction enableDiscovery() {\r\n\t\t    return saveProfile({enabled : true})\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t *\r\n\t\t * @param profileChanges the changes to save, or null if a new profile\r\n\t\t * @returns {IPromise<TResult>}\r\n\t\t */\r\n\t\tfunction saveProfile(profileChanges) {\r\n\t\t\t$log.log('saving profile')\r\n\r\n\t\t\treturn server.saveProfile(service.profile, profileChanges)\r\n\t\t\t\t.then(function(result) {\r\n\t\t\t\t\treturn service.profile\r\n\t\t\t\t})\r\n\t\t}\r\n\r\n\t\tfunction logout() {\r\n\t\t\t$analytics.eventTrack('logout')\r\n\t\t\tservice.userId = null\r\n\t\t\tservice.fbId = null\r\n\t\t\tservice.profile = null\r\n\t\t\tmatches = []\r\n\t\t\tprofileCache = []\r\n\t\t\tactiveChatMatchId = null\r\n\t\t\tactiveChatMessages = null\r\n\t\t\tunreadChats = {}\r\n\t\t\tunreadChatsCount = 0\r\n\t\t\tif(synchronizeInterval) {\r\n\t\t\t\t$interval.cancel(synchronizeInterval)\r\n\t\t\t\tsynchronizeInterval = null\r\n\t\t\t}\r\n\t\t\t// TODO wait for all the server/fb logout calls to complete before going to sign-in\r\n\t\t\tserver.logout()\r\n\t\t\tlocalStorage.clear()\r\n\t\t\t$localStorage.$reset()\r\n\t\t\tLocalDB.deleteDb()\r\n\t\t\t// TODO do we need to clear the image cache?\r\n\t\t\tif($rootScope.facebookConnected) {\r\n\t\t\t    $log.log('logging out of Facebook')\r\n\t\t\t    $cordovaFacebook.logout().then(function (result) {\r\n\t\t\t        $log.log('logged out of facebook')\r\n\t\t\t        delete $rootScope.facebookConnected\r\n\t\t\t        delete $rootScope.fbAccessToken\r\n\t\t\t    }, function (error) {\r\n\t\t\t        // possible message from FB JS: FB.logout() called without an access token.\r\n\t\t\t        $log.log('error logging out of Facebook ' + JSON.stringify(error))\r\n\t\t\t    })\r\n\t\t\t}\r\n\r\n\t\t\t$ionicHistory.clearCache()\r\n\t\t\t$ionicHistory.nextViewOptions({\r\n\t\t\t\tdisableBack: true\r\n\t\t\t})\r\n\t\t\t$state.go('signin')\r\n\t\t}\r\n\r\n\t\tfunction deleteAccount() {\r\n\t\t\t$analytics.eventTrack('deleteAccount')\r\n\t\t\treturn server.deleteAccount()\r\n\t\t}\r\n\r\n\t\tfunction deleteUnmatched() {\r\n\t\t\treturn server.deleteUnmatched()\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Process a like/pass on a profile\r\n\t\t * @param profile\r\n\t\t * @param {boolean} liked\r\n\t\t * @returns {Promise.<T>}\r\n\t\t */\r\n\t\tfunction processMatch(profile, liked) {\r\n\t\t\t$analytics.eventTrack('swipe', {liked:liked ? 'true' : 'false'})\r\n\t\t\treturn server.processProfile(profile, liked).then(function(match) {\r\n\t\t\t\t$log.log('processed match action')\r\n\t\t\t\t// If it's a mutual match then store the match with the profile\r\n\t\t\t\tif(match != null && match.state == 'M') {\r\n\t\t\t\t\tgetProfileByMatchId(match.id).then(function(profile){\r\n\t\t\t\t\t\tmatch.profile = profile\r\n\t\t\t\t\t\t//\tprofileCache[profile.id] = profile\r\n\t\t\t\t\t\tmatches.push(match)\r\n\t\t\t\t\t\tLocalDB.saveMatch(match, profile)\r\n\t\t\t\t\t\t$rootScope.$broadcast('newMatch', match)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}, function(error) {\r\n\t\t\t\t$log.error('error processing match ' + JSON.stringify(error))\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Push notification handler for a new mutual match\r\n\t\t * @param matchId\r\n\t\t */\r\n\t\tfunction newMatchNotification(matchId) {\r\n\t\t\t// We could have a Parse API call or two less by loading the match directly, but this ensure we're up to date\r\n\t\t\t// in case a push notification was dropped or not received.\r\n\t\t\tsynchronizeMutualMatches().then(newMatches => {\r\n\t\t\t\tif(newMatches.length && service.profile.notifyMatch) {\r\n\t\t\t\t\tvar media = new Media(filePath('audio/match-notification.mp3'), null, null, null);\r\n\t\t\t\t\t$cordovaMedia.play(media);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Call when the this user removes a matched user\r\n\t\t * @param matchId\r\n\t\t */\r\n\t\tfunction removeMatch(matchId) {\r\n\t\t\t$analytics.eventTrack('removeMatch')\r\n\t\t\t$log.log('removeMatch ' + matchId)\r\n\t\t\treturn server.removeMatch(matchId).then(function(result) {\r\n\t\t\t\t// remove the match from our local db and memory copy\r\n\t\t\t\tLocalDB.deleteMatch(matchId)\r\n\t\t\t\t_.remove(matches, {id: matchId})\r\n\t\t\t})\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Called when the other user removes this user (either via push notification or server sync)\r\n\t\t * @param matchId\r\n\t\t */\r\n\t\tfunction removeMatchNotification(matchId) {\r\n\t\t\t$log.log('removeMatchNotification ' + matchId)\r\n\t\t\tif(matches)\r\n\t\t\t\t_.remove(matches, {id: matchId})\r\n\t\t\tif(activeChatMatchId == matchId) {\r\n\t\t\t\tactiveChatMatchId = null\r\n\t\t\t\tactiveChatMessages = null\r\n\t\t\t\t$log.log('cleared active chat from remove notification')\r\n\t\t\t}\r\n\t\t\tLocalDB.deleteMatch(matchId)\r\n\t\t\t$rootScope.$broadcast('matchRemoved', matchId)\r\n\t\t}\r\n\r\n\r\n\t\tfunction getPotentialMatches() {\r\n\t\t\treturn service.potentialMatches\r\n\t\t}\r\n\r\n\t\tfunction updatePotentialMatches() {\r\n\t\t\t$analytics.eventTrack('searchProfiles')\r\n\t\t\treturn server.searchProfiles(service.profile).then(function(profiles) {\r\n\t\t\t\tservice.potentialMatches = profiles\r\n\t\t\t\t$rootScope.$broadcast('newPotentialMatches')\r\n\t\t\t\treturn service.potentialMatches\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Clear the existing search results, e.g. when changing the search settings\r\n\t\t */\r\n\t\tfunction clearPotentialMatches() {\r\n\t\t\tservice.potentialMatches = null\r\n\t\t}\r\n\r\n\r\n\t\tfunction getMutualMatches() {\r\n\t\t\t$log.log('getMutualMatches()')\r\n\t\t\tif(matches != null) {\r\n\t\t\t\treturn matches\r\n\t\t\t}\r\n\r\n\t\t\tmatches = []\r\n\r\n\t\t\treturn LocalDB.getMatches().then(function(dbMatches) {\r\n\t\t\t\tfor(let match of dbMatches) {\r\n\t\t\t\t\tmatches.push(match)\r\n\t\t\t\t\tprofileCache[match.profile.id] = match.profile\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// load any new matches from the server asynchronously\r\n\t\t\t\tsynchronizeMutualMatches()\r\n\t\t\t\treturn matches\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Load the mutual matches from the server and update our local copy\r\n\t\t * @returns {Promise<IMatch[]> any new mutual matches\r\n\t\t */\r\n\t\tfunction synchronizeMutualMatches() {\r\n\t\t\t$log.debug('synchronizeMutualMatches()')\r\n\t\t\treturn server.reloadUser().then(user => {\r\n\r\n\t\t\t\tvar localMatchIds = _.pluck(matches, 'id')\r\n\t\t\t\tvar serverMatchIds = user.matches\r\n\t\t\t\tvar toRemove = _.difference(localMatchIds, serverMatchIds)\r\n\t\t\t\tvar toAdd = _.difference(serverMatchIds, localMatchIds)\r\n\t\t\t\t$log.debug('Found ' + toRemove.length + ' mutual matches to remove')\r\n\t\t\t\t$log.debug('Found ' + toAdd.length + ' mutual matches to add')\r\n\r\n\t\t\t\t// Ok to remove these async in the background. It should complete by the following server call anyway.\r\n\t\t\t\tfor(let removeId of toRemove)\r\n\t\t\t\t\tremoveMatchNotification(removeId)\r\n\r\n\t\t\t\treturn server.getMatches(toAdd)\r\n\r\n\t\t\t}).then(newMatches => {\r\n\t\t\t\t$log.debug('loaded ' + newMatches.length + ' matches to sync')\r\n\t\t\t\tvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\r\n\t\t\t\tfor(let match of newMatches) {\r\n\t\t\t\t\t$log.debug('syncing new match ' + match.id)\r\n\t\t\t\t\t// TODO extract into some nice Date util methods\r\n\t\t\t\t\tlet createdAt = new Date(match.createdAt)\r\n\t\t\t\t\tlet formattedDate = createdAt.getDate() + ' ' + months[createdAt.getMonth()]\r\n\t\t\t\t\tmatch.lastMessage = 'Matched on ' + formattedDate\r\n\t\t\t\t\tmatches.unshift(match)\r\n\t\t\t\t\tlet profile = match.profile\r\n\t\t\t\t\tLocalDB.saveMatch(match, profile)\r\n\t\t\t\t\tprofileCache[profile.id] = profile\r\n\t\t\t\t}\r\n\t\t\t\tif(newMatches.length) {\r\n\t\t\t\t\t// TODO unread\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn newMatches\r\n\t\t\t})\r\n\t\t\t// log any errors an rethrow?\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Loads the chat messages from the server since the date stored in $localStorage.lastChatSync, or from the\r\n\t\t * beginning if there is no local storage value yet\r\n\t\t * @returns {Promise.<ChatMessage[]>}\r\n\t\t */\r\n\t\tfunction synchronizeChatMessages() {\r\n\r\n\t\t\tif(matches.length === 0)\r\n\t\t\t\treturn $q.when([])\r\n\r\n\t\t\tvar matchesById = _.indexBy(matches, 'id');\r\n\t\t\tvar lastChatSync = $localStorage.lastChatSync\r\n\t\t\t$log.info('synchronizing chat messages' + (lastChatSync ? ' from ' + lastChatSync : ''))\r\n\r\n\t\t\treturn server.loadChatMessages(lastChatSync)\r\n\t\t\t\t.then(function(messages) {\r\n\t\t\t\t\t$log.info('Found ' + messages.length + ' chat messages to synchronize')\r\n\t\t\t\t\tfor(let message of messages) {\r\n\t\t\t\t\t\tlet match = matchesById[message.match.id]\r\n\t\t\t\t\t\t// Note: match may be null if its been removed by either user, or if it is a chat message\r\n\t\t\t\t\t\t// from a new match which we haven't synced yet.\r\n\t\t\t\t\t\tLocalDB.saveChatMessage(message).then(function(isNew) {\r\n\t\t\t\t\t\t\tif(isNew && match) {\r\n\t\t\t\t\t\t\t\tmatch.read = false\r\n\t\t\t\t\t\t\t\tmatch.lastMessage = message.text\r\n\t\t\t\t\t\t\t\tupdateUnreadChatsCount(match.id, false)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Store where we have synced up to (i.e. the maximum createdAt in the messages array)\r\n\t\t\t\t\tif(messages.length)\r\n\t\t\t\t\t\t$localStorage.lastChatSync = _.max(_.pluck(messages, \"createdAt\"))\r\n\r\n\t\t\t\t\t// TODO need to sort by match last updated\r\n\r\n\t\t\t\t\tif(activeChatMatchId) {\r\n\t\t\t\t\t\tvar activeMsgsById = _.indexBy(activeChatMessages, 'id')\r\n\r\n\t\t\t\t\t\tfor(let msg of messages) {\r\n\t\t\t\t\t\t\t// if the msg belong to the active match and not in the active msg array, then add it\r\n\t\t\t\t\t\t\tif(msg.match.id == activeChatMatchId && !activeMsgsById[msg.id]) {\r\n\t\t\t\t\t\t\t\tvar sortedInsertPosition = _.sortedIndex(activeChatMessages, msg.createdAt, 'createdAt');\r\n\t\t\t\t\t\t\t\tactiveChatMessages.splice(sortedInsertPosition, 0, msg)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn messages\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Get a mutual match\r\n\t\t * @param matchId\r\n\t\t * @returns {IMatch}\r\n\t\t */\r\n\t\tfunction getMatch(matchId) {\r\n\t\t\treturn _.find(matches, 'id', matchId)\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Sets and return the active chat. New messages will be added to the array returned\r\n\t\t * @param matchId\r\n\t\t * @returns {IPromise<IChatMessage[]>}\r\n\t\t */\r\n\t\tfunction getActiveChat(matchId) {\r\n\t\t\t$log.log('getActiveChat ' + matchId)\r\n\r\n\t\t\tif(matchId === activeChatMatchId)\r\n\t\t\t\treturn $q.when(activeChatMessages)\r\n\r\n\t\t\treturn LocalDB.getChatMessages(matchId).then(function(messages) {\r\n\t\t\t\tactiveChatMatchId = matchId\r\n\t\t\t\tactiveChatMessages = messages\r\n\t\t\t\treturn activeChatMessages\r\n\t\t\t})\r\n\t\t}\r\n\r\n\r\n\r\n\t\t/**\r\n\t\t * Update the read flag on a chat\r\n\t\t * @param matchId the match/chat id\r\n\t\t * @param read {boolean} the new read value\r\n\t\t */\r\n\t\tfunction setChatRead(matchId, read) {\r\n\t\t\tif(!_.isBoolean(read))\r\n\t\t\t\tthrow 'read must be a boolean'\r\n\r\n\t\t\tvar match = _.find(matches, {'id': matchId})\r\n\t\t\tif(match != null && match.read != read) {\r\n\t\t\t\tmatch.read = read\r\n\t\t\t\tLocalDB.setChatRead(matchId, read)\r\n\r\n\t\t\t\tupdateUnreadChatsCount(matchId, read)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Update the cached state of which chats are (un)read so the unread chats count can easily be determined\r\n\t\t * @param matchId the match/chat id\r\n\t\t * @param {number|boolean} read if the chat is read/unread. A number or boolean is valid. 0 == false, 1 == true.\r\n\t\t */\r\n\t\tfunction updateUnreadChatsCount(matchId, read) {\r\n\t\t\tif(read === true || read === 1)\r\n\t\t\t\tdelete unreadChats[matchId]\r\n\t\t\telse if(read === false || read === 0)\r\n\t\t\t\tunreadChats[matchId] = true\r\n\t\t\telse\r\n\t\t\t\t$log.error('Invalid read argument to updateUnreadChatsCount()')\r\n\r\n\t\t\tunreadChatsCount = _.keys(unreadChats).length\r\n\t\t\t$log.log('unread chats: ' + unreadChatsCount)\r\n\t\t\t$rootScope.$broadcast('unreadChatsCountUpdated')\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Gets the number of chats that have unread messages. Can be used to check if there are any unread chats\r\n\t\t * (for example to change or decorate a chat icon)\r\n\t\t * @returns {number}\r\n\t\t */\r\n\t\tfunction getUnreadChatsCount() {\r\n\t\t\treturn unreadChatsCount\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Reset the notification badge number (for iOS)\r\n\t\t * See http://blog.parse.com/announcements/badge-management-for-ios/\r\n\t\t * @returns\r\n\t\t */\r\n\t\tfunction resetBadge() {\r\n\t\t\treturn server.resetBadge()\r\n\t\t}\r\n\r\n\r\n\t\tfunction sendChatMessage(matchId, text) {\r\n\t\t\t$analytics.eventTrack('chatMessage')\r\n\t\t\tvar match = new Match()\r\n\t\t\tmatch.id = matchId\r\n\t\t\tvar message = new ChatMessage()\r\n\t\t\tmessage.match = match\r\n\t\t\tmessage.text = text\r\n\t\t\tmessage.senderName = service.profile.name\r\n\r\n\t\t\treturn server.sendChatMessage(message, _.find(matches, {'id': matchId})).then(function(savedMessage) {\r\n\t\t\t\t$log.log('sent chat message for match ' + matchId)\r\n\t\t\t\tif(activeChatMatchId == matchId) {\r\n\t\t\t\t\t$log.log('adding to active chat messages')\r\n\t\t\t\t\tactiveChatMessages.push(savedMessage)\r\n\t\t\t\t}\r\n\t\t\t\tsaveNewMessage(matchId, savedMessage)\r\n\r\n\t\t\t\treturn savedMessage\r\n\t\t\t})\r\n\t\t}\r\n\r\n\r\n\t\tfunction reportProfile(profile, match) {\r\n\t\t\t$analytics.eventTrack('reportProfile')\r\n\t\t\treturn server.reportProfile(profile, match)\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Saves a new chat message locally, and updates the lastMessage on the Match object, and re-sorts the matches\r\n\t\t * @param matchId\r\n\t\t * @param message\r\n\t\t */\r\n\t\tfunction saveNewMessage(matchId, message) {\r\n\t\t\t// update the last message text on the match object.\r\n\t\t\tvar match = _.find(matches, {'id': matchId})\r\n\t\t\tif(match) {\r\n\t\t\t\tmatch.lastMessage = message.text\r\n\t\t\t\tmatch.updatedAt = message.createdAt\r\n\t\t\t\t// sort so matches with the newest messages are at the top\r\n\t\t\t\tmatches.sort(function(a,b) {\r\n\t\t\t\t\tif(a.updatedAt.getTime() == b.updatedAt.getTime()) return 0\r\n\t\t\t\t\treturn a.updatedAt.getTime() > b.updatedAt.getTime() ? -1 : 1\r\n\t\t\t\t})\r\n\t\t\t}\r\n\r\n\t\t\tLocalDB.saveChatMessage(message)\r\n\t\t\tif(message.sender != server.getUserId()) {\r\n\t\t\t\tsetChatRead(matchId, false)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Call when a push notification has been received so the polling for updates can be cancelled\r\n\t\t */\r\n\t\tfunction pushNotificationReceived() {\r\n\t\t\tif(synchronizeInterval) {\r\n\t\t\t\t$log.log('Cancelling chat synchronization interval')\r\n\t\t\t\t$interval.cancel(synchronizeInterval)\r\n\t\t\t\tsynchronizeInterval = null\r\n\t\t\t\t$localStorage.pushNotificationReceived = true\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction newMessageNotification(message) {\r\n\t\t\t$log.log('newMessageNotification ' + JSON.stringify(message))\r\n\t\t\tmessage.createdAt = new Date(message.createdAt)\r\n\r\n\t\t\tif(activeChatMatchId == message.match.id)\r\n\t\t\t\tactiveChatMessages.push(message)\r\n\r\n\t\t\tsaveNewMessage(message.match.id, message)\r\n\t\t\tupdateUnreadChatsCount(matchId, false)\r\n\r\n\t\t\t$rootScope.$broadcast('newMessage', message)\r\n\t\t\t$rootScope.$apply() // apply scope where newMessage event is received?\r\n\r\n\t\t\tif(service.profile.notifyMessage) {\r\n\t\t\t\tvar media = new Media(filePath('audio/chat-notification.mp3'), null, null, null);\r\n\t\t\t\t$cordovaMedia.play(media);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction sendContactMessage(message) {\r\n\t\t\t$analytics.eventTrack('contactMessage')\r\n\t\t\treturn server.sendContactMessage(message)\r\n\t\t}\r\n\r\n\r\n        function filePath(file) {\r\n            if(ionic.Platform.isIOS())\r\n                return file\r\n            else if(ionic.Platform.isAndroid())\r\n                return '/android_asset/www/' + file\r\n            else\r\n                return file\r\n        }\r\n\r\n\t\tfunction setPhoto(base64data) {\r\n\r\n\t\t\treturn server.saveFile(\"photo.png\", base64data).then(file => {\r\n\t\t\t\t$log.log('photo saved. saving profile...')\r\n\t\t\t\tvar profileUpdate = {}\r\n\t\t\t\tprofileUpdate.photos = service.profile.photos\r\n\t\t\t\tif(!profileUpdate.photos) {\r\n\t\t\t\t\tprofileUpdate.photos = []\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprofileUpdate.photos.push(file)\r\n\r\n\t\t\t\treturn server.saveProfile(service.profile, profileUpdate)\r\n\t\t\t}).then(result => {\r\n\t\t\t\t$log.log(\"saved profile with photo\")\r\n\t\t\t\treturn result\r\n\t\t\t}, error => {\r\n\t\t\t\t$log.log(\"error saving photo file to profile \" + JSON.stringify(error))\r\n\t\t\t\treturn $q.reject(error)\r\n\t\t\t})\r\n\t\t}\r\n\r\n\r\n\t\tfunction saveBirthdate(birthdate) {\r\n\t\t\tservice.profile.birthdate = birthdate\r\n\t\t\tservice.profile.ageFrom = service.profile.age - 5\r\n\t\t\tif(service.profile.ageFrom < 18) service.profile.ageFrom = 18\r\n\t\t\tservice.profile.ageTo = service.profile.age + 5\r\n\t\t\treturn server.saveProfile(service.profile, service.profile)\r\n\t\t}\r\n\r\n\t\tfunction convertImgToBase64(url, outputFormat){\r\n\t\t\tvar q = $q.defer()\r\n\t\t    var canvas = document.createElement('CANVAS'),\r\n\t\t        ctx = canvas.getContext('2d'),\r\n\t\t        img = new Image\r\n\t\t    img.crossOrigin = 'Anonymous'\r\n\t\t    img.onload = function(){\r\n\t\t        var dataURL\r\n\t\t        canvas.height = img.height\r\n\t\t        canvas.width = img.width\r\n\t\t        ctx.drawImage(img, 0, 0)\r\n\t\t        dataURL = canvas.toDataURL(outputFormat)\r\n\t\t        canvas = null\r\n\t\t\t\tq.resolve(dataURL)\r\n\t\t    }\r\n\t\t\timg.onerror = function(){ q.reject('Failed to load image ' + url)}\r\n\t\t    img.src = url\r\n\t\t\treturn q.promise\r\n\t\t}\r\n\t})\r\n\r\n})(); // end IIFE\r\n","angular.module('ionicApp').config(['$provide', 'parseSubDomain', function ($provide, parseSubDomain) {\n    if (!parseSubDomain) {\n        console.log('parseSubDomain config value not configured for logging');\n        return;\n    }\n    $provide.decorator('$log', ['$delegate', function ($delegate) {\n        var debugFn = $delegate.debug;\n        var infoFn = $delegate.info;\n        var logFn = $delegate.log;\n        var warnFn = $delegate.warn;\n        var errorFn = $delegate.error;\n        const MAX_RECENT = 10;\n        const MIN_TIME_DELAY = 10 * 1000;\n        var recent = [];\n        var lastError = '';\n        var lastSubmitTime = 0;\n        // Update the list of recent $log messages\n        function updateRecent(args) {\n            try {\n                if (args[0]) {\n                    recent.unshift(args[0]);\n                    if (recent.length > MAX_RECENT)\n                        recent.pop();\n                }\n            }\n            catch (e) {\n            }\n        }\n        $delegate.debug = function () {\n            var args = [].slice.call(arguments);\n            debugFn.apply(null, args);\n            updateRecent(args);\n        };\n        $delegate.info = function () {\n            var args = [].slice.call(arguments);\n            infoFn.apply(null, args);\n            updateRecent(args);\n        };\n        $delegate.log = function () {\n            var args = [].slice.call(arguments);\n            logFn.apply(null, args);\n            updateRecent(args);\n        };\n        $delegate.warn = function () {\n            var args = [].slice.call(arguments);\n            warnFn.apply(null, args);\n            updateRecent(args);\n        };\n        $delegate.error = function () {\n            var args = [].slice.call(arguments);\n            errorFn.apply(null, args);\n            try {\n                var user = Parse.User.current();\n                var userId = user ? user.id : '';\n                var errorMessage = args[0] || '';\n                if (errorMessage !== lastError && Date.now() > (lastSubmitTime + MIN_TIME_DELAY)) {\n                    var xmlHttp = new XMLHttpRequest();\n                    xmlHttp.open('POST', 'http://' + parseSubDomain + '.parseapp.com/client-log', true);\n                    xmlHttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n                    var data = 'userId=' + encodeURIComponent(userId) + '&message=' + encodeURIComponent(errorMessage) + '&recent=' + encodeURIComponent(JSON.stringify(recent));\n                    lastError = errorMessage;\n                    lastSubmitTime = Date.now();\n                    xmlHttp.send(data);\n                }\n            }\n            catch (e) {\n                console.log('Error submitting error log to server:' + e);\n            }\n            updateRecent(args);\n        };\n        return $delegate;\n    }]);\n}]);\n","var app;\n(function (app) {\n    /**\n     * Methods for authentication with social sites\n     */\n    var SocialAuth = (function () {\n        function SocialAuth($q, $log, $http, $translate) {\n            this.$q = $q;\n            this.$log = $log;\n            this.$http = $http;\n            this.$translate = $translate;\n            // $translate(['REQUEST_FAILED']).then(translationsResult => this.translations = translationsResult)\n        }\n        /*\n         * Modified from https://github.com/driftyco/ng-cordova/blob/master/src/plugins/oauth.js\n         *\n         * Sign into the LinkedIn service\n         * https://developer.linkedin.com/docs/oauth2\n         *\n         * @param    string clientId\n         * @param    string clientSecret\n         * @param    array appScope - the permission scope to authorise. For example r_basicprofile, r_emailaddress\n         * @param    string state - A random string to test again CSRS attacks\n         * @return   promise - Resolves to the authentication data\n         */\n        SocialAuth.prototype.linkedIn = function (clientId, clientSecret, appScope, state) {\n            var _this = this;\n            var deferred = this.$q.defer();\n            if (window.cordova) {\n                var cordovaMetadata = cordova.require('cordova/plugin_list').metadata;\n                if (cordovaMetadata.hasOwnProperty('cordova-plugin-inappbrowser') === true || cordovaMetadata.hasOwnProperty('org.apache.cordova.inappbrowser') === true) {\n                    var browserRef = window.open('https://www.linkedin.com/uas/oauth2/authorization?client_id=' + clientId + '&redirect_uri=http://localhost/callback&scope=' + appScope.join(' ') + '&response_type=code&state=' + state, '_blank', 'location=no,clearsessioncache=yes,clearcache=yes');\n                    browserRef.addEventListener('loadstart', function (event) {\n                        if ((event.url).indexOf('http://localhost/callback') === 0) {\n                            var requestToken = (event.url).split('code=')[1];\n                            _this.$http.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n                            _this.$http({ method: 'post', url: 'https://www.linkedin.com/uas/oauth2/accessToken', data: 'client_id=' + clientId + '&client_secret=' + clientSecret + '&redirect_uri=http://localhost/callback' + '&grant_type=authorization_code' + '&code=' + requestToken }).success(function (data) {\n                                deferred.resolve(data);\n                            }).error(function (data, status) {\n                                deferred.reject('Problem authenticating');\n                            }).finally(function () {\n                                setTimeout(function () {\n                                    browserRef.close();\n                                }, 10);\n                            });\n                        }\n                    });\n                    browserRef.addEventListener('exit', function (event) {\n                        deferred.reject('The sign in flow was canceled');\n                    });\n                }\n                else {\n                    deferred.reject('Could not find InAppBrowser plugin');\n                }\n            }\n            else {\n                deferred.reject('Cannot authenticate via a web browser');\n            }\n            return deferred.promise;\n        };\n        SocialAuth.socialAuthFactory = function ($q, $log, $http, $tanslate) {\n            return new SocialAuth($q, $log, $http, $tanslate);\n        };\n        return SocialAuth;\n    })();\n    app.SocialAuth = SocialAuth;\n    SocialAuth.socialAuthFactory.$inject = ['$q', '$log', '$http', '$translate'];\n    angular.module('SocialAuth', ['pascalprecht.translate']).factory('SocialAuth', SocialAuth.socialAuthFactory);\n})(app || (app = {}));\n","var app;\n(function (app) {\n    /**\n     * Utilities which simplify common actions and abstracts the implementation so it easier to make application wide\n     * changes to blocking calls, toasts etc\n     */\n    var AppUtil = (function () {\n        function AppUtil($q, $ionicLoading, $mdToast, $translate, $log) {\n            var _this = this;\n            this.$q = $q;\n            this.$ionicLoading = $ionicLoading;\n            this.$mdToast = $mdToast;\n            this.$log = $log;\n            this.$translate = $translate;\n            $translate(['REQUEST_FAILED']).then(function (translationsResult) { return _this.translations = translationsResult; });\n        }\n        /**\n         * Shows a toast message\n         * @param message\n         */\n        AppUtil.prototype.toastSimple = function (message) {\n            this.$mdToast.show(this.$mdToast.simple().content(message).hideDelay(2000));\n        };\n        /**\n         * Shows a toast message\n         * @param translateKey the key used to lookup the translated message\n         */\n        AppUtil.prototype.toastSimpleTranslate = function (translateKey) {\n            var _this = this;\n            this.$translate([translateKey]).then(function (result) {\n                let translation = result[translateKey];\n                if (translation === translateKey)\n                    _this.$log.warn('Invalid translation key ' + translateKey);\n                _this.toastSimple(translation);\n            }, function (error) { return _this.$log.warn('toast translation error ' + JSON.stringify(error)); });\n        };\n        /**\n         * A utility to simplify the common case of making a server call which blocks the user interface, and provides\n         * translation of errors.\n         *\n         * This is an example of how you might use it:\n         * function setLocation = () => AppUtil.blockingCall(\n         *        AppService.saveLocation(newLocation),\n         *        (result) => {marker.setLocation(result); AppUtil.toastSimple('LOCATION_UPDATED')}\n         *        )\n         *\n         * @param promise the promise to resolve\n         * @param successFunction the function to call on resolution of the promise\n         * @param errorTranslateKey the translation key to display an error message for on error\n         * @param errorMessage if no translation key is provided, then displays this error message on an error\n         * @returns {ng.IPromise<any>} the promise passed in as the first argument\n         */\n        AppUtil.prototype.blockingCall = function (promise, successFunction, errorTranslateKey, errorMessage) {\n            var _this = this;\n            var ionicLoading = this.$ionicLoading;\n            ionicLoading.show({ templateUrl: 'loading.html' });\n            promise.then(function (result) {\n                ionicLoading.hide();\n                successFunction(result);\n            }, function (error) {\n                ionicLoading.hide();\n                let customError = _this.resolveErrorMessage(error);\n                if (customError) {\n                    _this.toastSimple(customError);\n                }\n                else if (errorTranslateKey) {\n                    _this.toastSimpleTranslate(errorMessage);\n                }\n                else if (errorMessage) {\n                    _this.toastSimple(errorMessage);\n                }\n                else {\n                    _this.toastSimple(_this.translations['REQUEST_FAILED']);\n                }\n            });\n            return promise;\n        };\n        /**\n         * Converts an error into a human friendly message for particular error messages\n         * @param error\n         * @returns {string} if there is a custom error message, else null\n         */\n        AppUtil.prototype.resolveErrorMessage = function (error) {\n            this.$log.error(JSON.stringify(error));\n            if (error.code) {\n                switch (error.code) {\n                    case 100 /* CONNECTION_FAILED */:\n                        return 'Request failed, try again';\n                    case 155 /* REQUEST_LIMIT_EXCEEDED */:\n                        return 'Server busy, try again later';\n                    case 209 /* INVALID_SESSION_TOKEN */:\n                        // TODO force logout/login\n                        return 'Invalid session. Log in again';\n                    default:\n                        return null;\n                }\n            }\n            return null;\n        };\n        AppUtil.appUtilFactory = function ($q, $ionicLoading, $mdToast, $translate, $log) {\n            return new AppUtil($q, $ionicLoading, $mdToast, $translate, $log);\n        };\n        return AppUtil;\n    })();\n    app.AppUtil = AppUtil;\n    AppUtil.appUtilFactory.$inject = ['$q', '$ionicLoading', '$mdToast', '$translate', '$log'];\n    angular.module('AppUtil', ['ionic', 'pascalprecht.translate', 'ngMaterial']).factory('AppUtil', AppUtil.appUtilFactory);\n})(app || (app = {}));\n"],"sourceRoot":"/source/"}